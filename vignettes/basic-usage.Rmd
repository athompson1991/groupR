---
title: "Basic Usage"
author: "Alex Thompson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", fig.width = 7, fig.height = 7, fig.align = "center")
library(groupR)
```

Data analysis can require aggregation across any number of categories. For example, suppose you have employee-level data with state and job title for each employee; you may be asked to produce four different counts with such data: 

- overall count
- count by state
- count by job title
- count by both state and job title

This kind of aggregation grows quickly as more groups are desired, and additional aggregations can complicate analysis (in SQL: sum, max, min, avg). Continuing with the employee example, a possible request from a manager could be counts by country, state, job title, gender, and company org, as well as an aggregation of average salary (median and mean), maximum age, and difference between median salary and mean salary. This is a complicated ask. Additionally, much of this work can be done using pivot tables in Excel, but some statistical methods - even something as simple as calculating the median - are unavailable using that tool, and many different pivot tables would need to be produced. The aim of this package is to simplify such analysis by doing the calculations all at once.

One thing worth pointing out is that aggregation like this requires granular data. Ideally - in a database sense - this means a table with a primary key; something along the lines of a unique row for every employee, customer, product, etc.

## Baseball Example

A dataset with player-level batting statistics for the 2016/2017 Major League Baseball season is included with this package. See details on this data with `?baseball`. There are a number of apparent _groups_ that the data can be aggregated by: league, division, position, and team. Similarly, there are some interesting statistics one might be interested in - total home runs, a count of player by each grouping, total hits, average games per player, etc. Here is how to do such a calculation:

```{r, cache=TRUE}
bball_groupr <- get_groups(
  df = baseball,
  groups = c("league", "division", "team", "Pos"),
  functions = list(
    total_homeruns = "sum(HR, na.rm = T)",
    player_count = "n()",
    total_hits = "sum(H, na.rm = T)",
    avg_games = "mean(G, na.rm = T)"
    )
)
```

The structure of this can be demonstrated with a print function:

```{r}
print(bball_groupr)
```

Each group combination level (for example, `n_3_group`) will be referred to as a _grouping level_. A specific observation can be extracted using the `extract_df` function like so:

```{r}
extract_df(bball_groupr, "league")
extract_df(bball_groupr, c("league", "division"))
```

A rough estimate of the corresponding SQL code:

```{sql, eval=F}
-- First extract_df call
select league, sum(HR), count(*), sum(H), avg(G)
from baseball
group by league
  
-- Second extract_df call
select league, division, sum(HR), count(*), sum(H), avg(G)
from baseball
group by league, division
```

With the  _groupr_ object, `bball_groupr`, further calculations might be desired. For example, the percentage of total hits that are homeruns might be interesting to look at. That can be calculated like so:

```{r}
hr_percent <- function(df) df$total_homeruns / df$total_hits
reworked_groupr <- group_obj_apply(
  group_obj = bball_groupr,
  new_functions = list(hr_percent = hr_percent),
  is_cbind = T
)
extract_df(reworked_groupr, "league")
```

